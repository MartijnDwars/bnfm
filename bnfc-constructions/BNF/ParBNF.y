-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParBNF where
import AbsBNF
import LexBNF
import ErrM

}

%name pSyntax Syntax
%name pRule Rule
%name pExpression Expression
%name pList List
%name pTerm Term

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '::=' { PT _ (TS _ 1) }
 '|' { PT _ (TS _ 2) }

L_quoted { PT _ (TL $$) }
L_NonTerminal { PT _ (T_NonTerminal $$) }
L_err    { _ }


%%

String  :: { String }  : L_quoted {  $1 }
NonTerminal    :: { NonTerminal} : L_NonTerminal { NonTerminal ($1)}

Syntax :: { Syntax }
Syntax : {- empty -} { SyntaxNil } 
  | Rule Syntax { SyntaxCons $1 $2 }


Rule :: { Rule }
Rule : NonTerminal '::=' Expression { Rule $1 $3 } 


Expression :: { Expression }
Expression : List { ExpressionList $1 } 
  | List '|' Expression { ExpressionOpt $1 $3 }


List :: { List }
List : Term { ListOne $1 } 
  | Term List { ListCons $1 $2 }


Term :: { Term }
Term : String { Literal $1 } 
  | NonTerminal { NonTerm $1 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

